# E-Value Solutions web app
Evaluate your property based on statistical formulas 

## Project Tools
- Back End: Python 3.6 and Flask Web Framework
- Front End: ES2015, React, Redux, Redux Saga, Gulp/Browserify, SASS, and Materialize CSS
- Database: Postgresql
- Caching/Memoizing: Redis 
- Hosting: Heroku (Postgres, Redis, Logentries and the app server are on Heroku)
- Backend Logging: Logentires 
- Frontend Logging: Sentry.io (Not working properly at the moment.)
- Data/Schema Migrations: Flask-Migrate (based on Alembic)
- ORM: Flask Sqlalchemy 


## Project Set Up
1. Download Repo
    - run `git clone https://GGross5213@bitbucket.org/agvalue/agvalue-web-app.git` to download repo
2. Python 
    - Download Python 3.6
    - Set up virtual env for project if you wish
    - Navigate to Project directory and run `pip install -r requirments.txt` to install python packages
3. Javascript
    - Download Node 8
    - Navigate to directory and run `npm install` to install js packages.
4. Docker/Db
    - Download Docker for windows or Docker for Mac (or the appropiate Docker for your OS)
    - Docker should come up with docker-compose if not download docker compose
    - Navigate to Directory and run `docker-compose build` and then run `docker-compose up`
    - This will start a Postgresql database in a Docker contianer and expose port 5432 on localhost for local development
5. Developing on the application
    - To start the server, run `python server.py`
    - In the `helpers.py` file there is a set script that creates the tables and some default data for the db if it is working with a new database. This is run automatically when you start the server.
    - To transpile JS files and watch for changes run `npm run watch`
    - You can now access the web app on http://localhost:5000


## Hosting/Deployment
The app server is hosted on heroku.com. The database, caching server and backeng logging service are also all through Heroku. The application runs on a 2x Standard server. The `Procile` defines how the application is started and a release command. The Release command runs the migration script. It checks to see if there is a script to be run and runs it. The Python server is being run using Gunicorn and Gevent to take advantage of the CPU.

The Heroku environment uses both a Node and Python buildpack which installs JS/Python packages before deployment. 

In order to deploy the application, download the Herkou CLI and follow the instructions

## Directory Description
I will go through and talk about the purpose of different files/folders
- server.py
    - Configures/Starts the Flask Server, runs a start up script to fill a new db with proper tables and holds some unauthenticated routes.
- Procile
    - defines commands to be run on Heroku upon deployment
- heleprs.py
    - defines some helper functions such as the `intialize_db` script, auth route decorater functions, and send email function
- gulpfile.js
    - transpiles all my browser code/resources 
- cache.py
    - Sets up server caching to help memoize small, frequent db calls
- templates - html files (by default Flask uses Jinja2 for templating)
    - index.html
        - This is where the magic happens. The REact app is mounted on this html file
- migrations
    - This holds all data/schema migrations for the db that get generated by Flask-Migrate
- models - DB Models built from Flask-Sqlalchemy, they are split up by namespace, all models have a save function and serialize function to make it JSON serializable
    - shared
        - creates the FlaskSqlalchemy session to connect to the db and allows it to be imported into all model files and the server.py
    - User - All models pertaining to the user
        - User
            - has login function and hash_password function
            - password hashing is done by passlib.hash, it uses sha256 and comes up with its own salt.
            - Every User has to be associated with an Organization and can only be associated with one.
        - SessionToken
            - Holds a session record everytime a User is logged in. 
            - Sessions have the potential to be revoked and are valid for 2 weeks
        - UserInvite
            - Contains information for a user invite that then is used to create a user once the user signs up
        - ForgotPassword
            - Creates a record of the token associated with a new password request
        - Role
            - There are 4 roles. Root Admin, App Admin, Org Admin, Org User
            - Root Admin and App Admin are given access to the Admin Portal to create/manage users and organizations
    - Organization
        - Organization
            - A client's organization
            - All evaluations are owned by an organization
        - Org Counties
            - Counties that an organization is allowed to see. This effects what land data an organization can use in its Evaluations and also effects what counties can be used in the Organization's Areas
        - Area
            - These are groups of counties that allow the user to filter Land Data
            - These are created by Curt upon the creation of an Organization and can be edited by Curt or other Root/App Admins
    - LandData
        - LandData
            - This is data about previously sold properties that Curt can upload. 
            - Parcel numbers and County combinations are unique. If a file with existing Parcel Number is uploaded, the upload funciton just updates the existing LandData
    - Address
        - Address
            - Address Model
        - County
            - County for LandData and Areas
    - __init__.py
        - An easy way to import models into other areas of the app
    - Evaluation - Contains all modesl pertaining to Evaluations
        - Evaluation
            - This is by far teh biggest/most complex model
            - It contains most of the information pertaining to an Evaluation
            - It has a `small_serialize` function which is used when more than one evaluation is being returned via JSON. This significantly cuts down the amount of data being transferred at a given time and the amount of time it takes to load a list of evaluations.
            - Market Type
                - Market Type can be EntireMarketArea, County, Area
                - If EntireMarketArea then market_area_county_id is None and market_area_id is none
                - If County then market_area_county_id points to the county and market_area_id is None
                - If Area then market_area_id points to an Area and market_area_county_id is None
            - Comments
                - There a comments that a User can add to a PDF. Due to a lot changes the field names in the db are still the old names of the fields.
                - `tax_overhead_notes` correlates to Comment1
                - `additional_exhibit_notes` correlates to Comment2
                - `soils_notes` correlates to Comment3
                - `flood_map_notes` correlates to Comment4
        - PropertyRating
            - The Evaluation contains a foreign key of a PropertyRating
        - StatisticalParameters
            - The Evaluation contains a foreign key of a StatisticalPArameters 
        - MarketTrendGraph
            - TrendData and ScatterData are lists of (x,y) pairs. They are converted to a string and comma separted to be stored in the Db. This is done in the ValuationSummary Component that displays the graph.
        - PDFImages
            - Stores images that are in teh PDF
            - Property Pictures
                - This is a string that is converted into a list where each element is a dictionary containing a fileURL that is a link to the file on Amazon s3
            - Signature
                - Dictionary converted to a string that contains fileURL
            - AdditionalExhibits
                - A List of Dictionaries converted to a string that contains a fileURL and name of the exhibit page
        - EvaluationSaveLog
            - These are created when an Evaluation Save meets the requirements of a chargable save.
            - The are also created when the last save meets the criteria but it doesn not contain a pdf. This is done to ensue they are only charged once the PDF is generated
            - Criteria: PDF is generated teh first time or the name, address or mapParcelNumber changes.
- routes - contains blueprints of routes that are separted by namespace
- static - contians the front end javascript/sass/css/images/fonts basically any asset that gets served to the browser
    - bin
        - contains the minified js and css as well as any js files that actually get served to the browser. all the other js files are transpiled into this folder as bundle.js
    - fonts - contains fonts that are served to the browser
    - scss - contains SASS files that are compiled into the app.css file and piped to the bin folder before being served to the browser
    - js - contains the front end single page application
        - app.js - The entry point of the React application. This initializes the Redux stores, Redux sagas, any other middleware, kicks off initial actions and mounts the React app
        - helpers.js - Some front end helper functions. A percision rounding function, numToCurrency function, export HTML to PDF function (This is a big one. This actually runs the code that takes the html and transforms it into a pdf), and url to data uri function (this allows us to not have to reference external urls for pictures or the pdf download.)
        - reducer.js - The Redux Reducer file where all reducers are combined
        - routes.js - Map routes to React components via React Router (I don't use the newest version because it is a huge change compared to how they used to do it)
        - saga.js - the root Redux Saga to handle asyn actions and pretty much any extra logic around an action
        - states.json - A big json file of states for a dropdown
        - ducks - This contains all Reducers, Sagas, Actions, and API functions separted by namespace. The ducks standard/protocal requires that each file's default export is the reducer and then you can export everything else by name. I have thought about turning each namespace into a folder with a separate file for the Reducer, API, sagas, and actions because they way I have it works great when starting out but as one namespace grows it becomes harder to maintain (ie Evaluations.js)
            - constants.js
                - The standard I use for actions and aciton creators is to have one action for all parts of an async action. What I mean by this is that if an action makes an API requests for example fetchEvaulations. The same action and action creator will handle the initial action request to fetch evaluations, the action to receive evaluations once the request returns and an error action if there is an error during the request. I do this by having constants which I call actionTypes. Every async actions needs a type and an actionType. I define the actionTpes in teh constants file. I really only use FETCH, RECEIVE, ERROR, and CREATE. I don't know if I actually use UPDATE anywhere.
                - This standard allows me to write less actions and makes writing reducers pretty easy. I have the main reducer that gets exported which has a switch for the type. Then that returns another function which has a switch for the actionType.
                - This file also contains a basic error handler function that is used by most sagas
            - evaluation.js -